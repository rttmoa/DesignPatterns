


    // 我们继续看上个小节举出的例子，简单工厂函数最后长这样：
    function Factory(name, age, career) {
        let work
        switch(career) {
            case 'coder':
                work =  ['写代码','写系分', '修Bug'] 
                break
            case 'product manager':
                work = ['订会议室', '写PRD', '催更']
                break
            case 'boss':
                work = ['喝茶', '看报', '见客户']
            case 'xxx':
                // 其它工种的职责分配
                // ... 
        } 
        return new User(name, age, career, work)
    } 
 
    // 乍一看没什么问题，但是经不起推敲呀。
        // 首先映入眼帘的 Bug，是我们把 Boss 这个角色和普通员工塞进了一个工厂。
        // 大家知道，Boss 和基层员工在职能上差别还是挺大的，具体在员工系统里怎么表现呢？
        // 首先他的权限就跟咱们不一样。有一些系统，比如员工绩效评估的打分入口，就只有 Boss 点得进去，对不对？
        // 除此之外还有许多操作，是只有管理层可以执行的，因此我们需要对这个群体的对象进行单独的逻辑处理。

    // 权限问题：因为公司不仅仅只有这两类人，
        // 除此之外还有外包同学、还有保安，他们的权限、职能都存在着质的差别
        // 他们的权限、职能都存在着质的差别。如果延续这个思路，每考虑到一个新的员工群体，就回去修改一次 Factory 的函数体，
        // 这样做糟糕透了——首先，是Factory会变得异常庞大，庞大到你每次添加的时候都不敢下手，生怕自己万一写出一个Bug
    // 没有遵守开放封闭原则。

    
    // 我们再复习一下开放封闭原则的内容：
    //     对拓展开放，对修改封闭。说得更准确点，软件实体（类、模块、函数）可以扩展，但是不可修改。
    //     楼上这波操作错就错在我们不是在拓展，而是在疯狂地修改。